# ðŸ”¹ AWS CDK App Lifecycle

The CDK app lifecycle is the sequence of phases your code goes through â€” from writing Python code to actual AWS resources being created.

---

# ðŸ”¹ High-Level Lifecycle Flowchart

```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  1. CONSTRUCTâ”‚   You write Python code (Stacks, Constructs)
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  2. INIT     â”‚   CDK creates the App tree in memory
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  3. SYNTH    â”‚   CDK converts your code â†’ CloudFormation JSON/YAML
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  4. PREPARE  â”‚   Final modifications before template generation
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  5. VALIDATE â”‚   CDK checks for errors in your constructs
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  6. DEPLOY   â”‚   CloudFormation creates real AWS resources
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  7. DESTROY  â”‚   (Optional) Tear down all resources
 â””â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€â”€â”€â”˜
```

---

# ðŸ”¹ Phase 1: CONSTRUCT (Write Your Code)

This is where you define your infrastructure in Python.

```python
from aws_cdk import App, Stack
from aws_cdk import aws_s3 as s3
from constructs import Construct

class MyStack(Stack):
    def __init__(self, scope: Construct, id: str, **kwargs):
        super().__init__(scope, id, **kwargs)

        # Define an S3 bucket
        s3.Bucket(self, "MyBucket",
            versioned=True,
            bucket_name="my-demo-bucket-12345"
        )

app = App()
MyStack(app, "MyStack")
app.synth()
```

**What happens here:**

* You create an `App` (root of everything)
* Inside the App, you create `Stack`(s)
* Inside Stacks, you create `Constructs` (S3, Lambda, etc.)

---

# ðŸ”¹ Phase 2: INIT (Build the Construct Tree)

When Python runs your code, CDK builds a **tree of constructs** in memory.

```
App (root)
 â””â”€â”€ MyStack
      â””â”€â”€ MyBucket (S3 Bucket)
```

**Real-world example with multiple resources:**

```python
class WebAppStack(Stack):
    def __init__(self, scope, id, **kwargs):
        super().__init__(scope, id, **kwargs)

        # VPC
        vpc = ec2.Vpc(self, "WebVpc", max_azs=2)

        # Security Group
        sg = ec2.SecurityGroup(self, "WebSG", vpc=vpc)

        # EC2 Instance
        ec2.Instance(self, "WebServer",
            vpc=vpc,
            instance_type=ec2.InstanceType("t2.micro"),
            machine_image=ec2.AmazonLinuxImage(),
            security_group=sg
        )
```

**Construct tree becomes:**

```
App
 â””â”€â”€ WebAppStack
      â”œâ”€â”€ WebVpc
      â”‚    â”œâ”€â”€ PublicSubnet1
      â”‚    â”œâ”€â”€ PublicSubnet2
      â”‚    â”œâ”€â”€ PrivateSubnet1
      â”‚    â””â”€â”€ PrivateSubnet2
      â”œâ”€â”€ WebSG
      â””â”€â”€ WebServer
```

> ðŸ’¡ CDK auto-generates subnets, route tables, and gateways inside a VPC â€” you don't see them in code, but they appear in the tree.

---

# ðŸ”¹ Phase 3: SYNTH (Synthesize)

**Command:**

```bash
cdk synth
```

**What happens:**

* CDK traverses the construct tree
* Converts every construct into CloudFormation template
* Outputs to `cdk.out/` directory

```
cdk.out/
 â”œâ”€â”€ MyStack.template.json      â† CloudFormation template
 â”œâ”€â”€ manifest.json               â† Deployment metadata
 â”œâ”€â”€ tree.json                   â† Full construct tree
 â””â”€â”€ cdk.out                     â† Assembly marker
```

**Example output (simplified CloudFormation):**

```json
{
  "Resources": {
    "MyBucket": {
      "Type": "AWS::S3::Bucket",
      "Properties": {
        "VersioningConfiguration": {
          "Status": "Enabled"
        },
        "BucketName": "my-demo-bucket-12345"
      }
    }
  }
}
```

**Key point:** No AWS resources are created yet. This is just template generation.

---

# ðŸ”¹ Phase 4: PREPARE

This phase runs automatically during `synth`.

* CDK calls `prepare()` on each construct (bottom-up)
* Used for last-minute modifications before template generation
* Most constructs don't override this â€” it's an advanced hook

**Example use case:**

```python
class MyConstruct(Construct):
    def __init__(self, scope, id):
        super().__init__(scope, id)
        self._connections = []

    # prepare() is called automatically by CDK before synthesis
    # Used internally by CDK constructs for final adjustments
```

> ðŸ’¡ You rarely write custom `prepare()` logic. CDK uses it internally to resolve references, tokens, and cross-stack dependencies.

---

# ðŸ”¹ Phase 5: VALIDATE

CDK checks your constructs for errors.

**Command (runs automatically during synth):**

```bash
cdk synth   # validate runs as part of synth
```

**Example â€” Adding validation to a custom construct:**

```python
class DatabaseStack(Stack):
    def __init__(self, scope, id, db_name: str, **kwargs):
        super().__init__(scope, id, **kwargs)
        self.db_name = db_name

        rds.DatabaseInstance(self, "Database",
            engine=rds.DatabaseInstanceEngine.mysql(
                version=rds.MysqlEngineVersion.VER_8_0
            ),
            instance_type=ec2.InstanceType("t3.micro"),
            vpc=ec2.Vpc(self, "DbVpc")
        )

    def validate(self):
        errors = []
        if len(self.db_name) < 3:
            errors.append("Database name must be at least 3 characters")
        return errors
```

**If validation fails:**

```
Error: Validation failed with the following errors:
  [MyStack] Database name must be at least 3 characters
```

---

# ðŸ”¹ Phase 6: DEPLOY

**Command:**

```bash
cdk deploy
```

**This is where real AWS resources are created.**

**Deployment flow:**

```
cdk deploy
    â”‚
    â”œâ”€â”€ 1. Run synth (if not already done)
    â”‚
    â”œâ”€â”€ 2. Upload assets to S3 (Bootstrap bucket)
    â”‚       â€¢ Lambda code zips
    â”‚       â€¢ Docker images â†’ ECR
    â”‚       â€¢ Large templates
    â”‚
    â”œâ”€â”€ 3. Submit template to CloudFormation
    â”‚
    â”œâ”€â”€ 4. CloudFormation creates/updates resources
    â”‚       â”œâ”€â”€ CREATE_IN_PROGRESS
    â”‚       â”œâ”€â”€ CREATE_IN_PROGRESS
    â”‚       â””â”€â”€ CREATE_COMPLETE
    â”‚
    â””â”€â”€ 5. Stack outputs displayed
         â€¢ Endpoint URLs
         â€¢ Resource ARNs
```

**Example terminal output:**

```
MyStack: deploying...
MyStack: creating CloudFormation changeset...

 âœ…  MyStack

Outputs:
MyStack.BucketArn = arn:aws:s3:::my-demo-bucket-12345

Stack ARN:
arn:aws:cloudformation:ap-south-1:339712902352:stack/MyStack/abc-123
```

---

# ðŸ”¹ Phase 7: DESTROY (Optional)

**Command:**

```bash
cdk destroy
```

* Deletes all resources in the stack
* Removes the CloudFormation stack
* Some resources may be retained (like S3 buckets with data)

**Example:**

```
Are you sure you want to delete: MyStack (y/n)? y
MyStack: destroying...

 âœ…  MyStack: destroyed
```

---

# ðŸ”¹ Complete Lifecycle Architecture Map

```
 YOU (Developer)
  â”‚
  â”‚  Write Python code
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CDK CLI                         â”‚
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ CONSTRUCT  â”‚â†’â”‚   INIT    â”‚â†’â”‚    SYNTH      â”‚ â”‚
â”‚  â”‚(your code) â”‚  â”‚(tree build)â”‚  â”‚(â†’ CFn JSON)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                        â”‚         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚         â”‚
â”‚  â”‚ VALIDATE   â”‚â†â”‚  PREPARE  â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚        â”‚                                         â”‚
â”‚        â”‚  âœ… Pass                                â”‚
â”‚        â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚  cdk.out/ folder   â”‚  â† Templates + Assets    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â”‚  cdk deploy
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                AWS Cloud                          â”‚
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  S3      â”‚    â”‚ CloudFormation  â”‚              â”‚
â”‚  â”‚(assets)  â”‚â”€â”€â”€â†’â”‚  (orchestrator) â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                          â”‚                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚              â–¼           â–¼           â–¼           â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚         â”‚  EC2   â”‚ â”‚   S3    â”‚ â”‚ Lambda  â”‚     â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                   â”‚
â”‚         Actual AWS Resources Created              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ðŸ”¹ CDK Commands â†” Lifecycle Phases

| Command         | Lifecycle Phases Triggered          |
|-----------------|-------------------------------------|
| `cdk synth`     | Construct â†’ Init â†’ Prepare â†’ Validate â†’ Synth |
| `cdk deploy`    | All of synth + Deploy               |
| `cdk destroy`   | Destroy                             |
| `cdk diff`      | Synth + Compare with deployed stack  |
| `cdk ls`        | Synth (lists stack names only)       |

---

# ðŸ”¹ Lifecycle with a Real Example

Let's trace a Lambda function through the entire lifecycle:

**Phase 1 & 2 â€” Construct & Init:**

```python
from aws_cdk import App, Stack, Duration
from aws_cdk import aws_lambda as _lambda
from constructs import Construct

class LambdaStack(Stack):
    def __init__(self, scope: Construct, id: str, **kwargs):
        super().__init__(scope, id, **kwargs)

        _lambda.Function(self, "HelloHandler",
            runtime=_lambda.Runtime.PYTHON_3_12,
            code=_lambda.Code.from_asset("lambda"),   # local folder
            handler="hello.handler",
            timeout=Duration.seconds(30),
            memory_size=256
        )

app = App()
LambdaStack(app, "LambdaStack")
app.synth()
```

**Phase 3 â€” Synth:**

```bash
cdk synth
```

CDK generates:

```
cdk.out/
 â”œâ”€â”€ LambdaStack.template.json
 â””â”€â”€ asset.a1b2c3d4e5/        â† Your lambda/ folder zipped
      â””â”€â”€ hello.py
```

**Phase 4 & 5 â€” Prepare & Validate:**

* CDK resolves the asset path
* Validates Lambda config (runtime, handler, etc.)

**Phase 6 â€” Deploy:**

```bash
cdk deploy
```

```
1. lambda/ folder â†’ zipped â†’ uploaded to S3 Bootstrap bucket
2. CloudFormation template submitted
3. AWS creates:
   â”œâ”€â”€ IAM Role (Lambda execution role)
   â””â”€â”€ Lambda Function (HelloHandler)
4. Output: Function ARN displayed
```

**Phase 7 â€” Destroy:**

```bash
cdk destroy
```

```
Lambda Function â†’ deleted
IAM Role â†’ deleted
CloudFormation Stack â†’ deleted
S3 asset â†’ remains in bootstrap bucket (not auto-cleaned)
```

---

# ðŸ”¹ Tokens and Lazy Resolution

An important concept during the lifecycle â€” **Tokens**.

When you reference a resource attribute before it exists, CDK uses **tokens** (placeholders).

```python
bucket = s3.Bucket(self, "MyBucket")
_lambda.Function(self, "MyFunc",
    environment={
        "BUCKET_NAME": bucket.bucket_name   # â† This is a TOKEN at init time
    }
)
```

**Lifecycle of a Token:**

```
INIT phase:     bucket.bucket_name = "${Token[TOKEN.123]}"  (placeholder)
SYNTH phase:    Resolved to â†’ { "Ref": "MyBucket" }        (CloudFormation reference)
DEPLOY phase:   Resolved to â†’ "mystack-mybucket-abc123"     (actual bucket name)
```

> ðŸ’¡ Tokens are why you can't do `if bucket.bucket_name == "something"` in CDK â€” at init time, it's not a real string yet.

---

# ðŸ”¹ Aspects â€” Hooks into the Lifecycle

Aspects let you visit every construct in the tree before synthesis.

**Example â€” Force all S3 buckets to have encryption:**

```python
import jsii
from aws_cdk import Aspects, IAspect
from aws_cdk import aws_s3 as s3

@jsii.implements(IAspect)
class BucketEncryptionChecker:
    def visit(self, node):
        if isinstance(node, s3.CfnBucket):
            # Force encryption on every bucket
            node.add_property_override(
                "BucketEncryption.ServerSideEncryptionConfiguration",
                [{"ServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]
            )

# Apply to entire app
Aspects.of(app).add(BucketEncryptionChecker())
```

**Where Aspects fit in the lifecycle:**

```
Construct â†’ Init â†’ Aspects Applied â†’ Prepare â†’ Validate â†’ Synth
                    â†‘
                    Runs here (after tree is built, before synth)
```

---

# ðŸ”¹ Common Errors at Each Phase

| Phase    | Common Error                          | Fix                                    |
|----------|---------------------------------------|----------------------------------------|
| Init     | `Cannot find module`                  | Install dependencies: `pip install`    |
| Synth    | `is not authorized to perform`        | Check IAM permissions                  |
| Validate | `Validation failed`                   | Fix construct configuration            |
| Deploy   | `CREATE_FAILED`                       | Check CloudFormation events console    |
| Deploy   | `Resource already exists`             | Use unique names or remove existing    |
| Deploy   | `Bootstrap not found`                 | Run `cdk bootstrap` first              |
| Destroy  | `Bucket not empty`                    | Empty S3 bucket first or use `auto_delete_objects=True` |

---

# ðŸ”¥ Interview-Ready Answer

If someone asks:

**What is the AWS CDK lifecycle?**

> The CDK lifecycle has these phases: **Construct** (write code), **Init** (build construct tree in memory), **Synth** (generate CloudFormation templates), **Prepare** (final adjustments), **Validate** (error checks), **Deploy** (CloudFormation creates real resources), and optionally **Destroy** (tear down resources). The key insight is that CDK code runs at synthesis time to produce CloudFormation templates â€” it doesn't directly create resources.

**What are Tokens in CDK?**

> Tokens are lazy placeholders that CDK uses when a resource attribute isn't known until deploy time. During init, they appear as placeholder strings. During synth, they're resolved to CloudFormation intrinsic functions like `Ref` or `Fn::GetAtt`. During deploy, CloudFormation resolves them to actual values.

---
